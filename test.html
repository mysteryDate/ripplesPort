<!DOCTYPE html>
<html>
<head>
	<title>TESTTING!</title>
	<script src="stats.min.js"></script>
    <script src="dat.gui.js"></script>

    <script src="three.r78.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        canvas {
        	width: 50px;
        }
    </style>
</head>
<body>

	<script id="vertex-shader" type="x-shader/x-vertex">
	    varying vec2 vUv;
	    void main() {
	    	vUv = uv;
	        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	    }
	</script>

	<script id="fragment-shader-simple" type="x-shader/x-fragment">
	    uniform sampler2D _mainTex;
	    varying vec2 vUv;

	    void main() {
	    	vec4 inTex = texture2D(_mainTex, vUv);
	    	gl_FragColor = inTex;
	    }
	</script>

	<script id="fragment-shader-pingpong" type="x-shader/x-fragment">
	    uniform sampler2D _mainTex;
	    uniform vec2 _hiPoint;
	    uniform vec2 _iResolution;
	    uniform float _mouseDown;
	    varying vec2 vUv;

	    void main() {
	    	if(_mouseDown > 0.5) {
		    	float dist = smoothstep(20.,0.,length(_hiPoint.xy - gl_FragCoord.xy));
		        gl_FragColor = vec4(vUv.xy,dist,1.);
		    }
		    else {
		    	vec4 inTex = texture2D(_mainTex, vUv) * 0.9;
		    	gl_FragColor = inTex;
		    }
	    }
	</script>

	<script type="text/javascript">
		var canvas = document.createElement('canvas');
		document.body.appendChild(canvas);
		var stats = new Stats();
        document.body.appendChild(stats.domElement);

        var renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        var gui = new dat.GUI();

        var plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
        var camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 300;
        // Separate camera for render to texture
        var cameraRTT = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
        // Texture to render to
        var tex1 = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, depthBuffer: false,
            stencilBuffer: false } );
        // For ping-ponging
        var tex2 = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, depthBuffer: false,
            stencilBuffer: false } );
        var pingpongMaterial = new THREE.ShaderMaterial( {
        	uniforms: {
        		_mainTex: { value: tex1.texture },
        		_hiPoint: { value: new THREE.Vector2(0., 0.)},
        		_mouseDown: {value: 1.}
        	},
        	vertexShader: document.getElementById('vertex-shader').textContent,
        	fragmentShader: document.getElementById('fragment-shader-pingpong').textContent
        });
        var dummyScene = new THREE.Scene();
        var dummyQuad = new THREE.Mesh(plane,pingpongMaterial);
        dummyScene.add(dummyQuad);

        var basicMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                _mainTex: { value: tex1.texture }
            },
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: document.getElementById('fragment-shader-simple').textContent
        });

        var scene = new THREE.Scene();
        var quad = new THREE.Mesh( plane, basicMaterial );
        scene.add( quad );

        var startTime = Date.now()/1000.;
        function render() 
        {
        	requestAnimationFrame(render);
            stats.update();
            renderer.render(dummyScene, cameraRTT, tex1);
            // Ping pong!
            var a = tex2;
            tex2 = tex1;
            tex1 = a;
            pingpongMaterial.uniforms._mainTex.value = tex2.texture;
        	renderer.render(scene, camera);
        }

        canvas.onmousedown = function(e) {
        	pingpongMaterial.uniforms._hiPoint.value = new THREE.Vector2(
        		e.clientX, window.innerHeight - e.clientY
        	);
        	pingpongMaterial.uniforms._mouseDown.value = 1.0;
        }
        canvas.onmouseup = function(e) {
        	pingpongMaterial.uniforms._mouseDown.value = 0.0;
        }
        render();
	</script>

</body>
</html>